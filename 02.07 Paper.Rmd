---
title: "Stop, Slow, Go, how stops affect bike travel efficieny"
author: Sophia Wentkowski & Jan Burri
output:
  html_document:
    theme: lumen
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
    toc_depth: 3
    code_folding: hide
    css: ./styles.css

date: | 
    |  
    | `r format(Sys.time(), '%B %d, %Y')`
documentclass: article
geometry: margin=1in
fontsize: 12pt
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(error = F)
library(tidyverse)
library(mapview)
library(sf)
library(tmap)
library(raster)
library(igraph)
library(terra)
library(leaflet)
library(leaflet.extras)
library(osrm)
library(captioner)
library(stplanr)
library(gridExtra)
```

# 1 Introduction

Getting from A to B is a matter we humans have been dealing with since the day of age. From only being able to get around by foot, technological advances have made it possible to move with more sophisticated methods such as cars, trains or planes. However, to this day, non motorized means of transportation remain a part of our life, such as the bicycle. The propulsion of bicycles is generated by the cyclist and hence requires some form of strength and energy from the operator. Jan Burri, one of the authors, cycles to rugby training twice a week and wants to know the most efficient way on how to get to training.

# 2 Background and Research Questions

According to the TomTom Traffic Index, Zurich City has the most traffic in Switzerland (TomTom Traffic Index, 2022). A survey made by the same navigation system also uncovered that over a quarter of the roads in Switzerland's primary business conglomeration are experiencing congestion (TomTom Traffic Index, 2023). This is mostly due to junctions with traffic lights according to research by the ETH Zürich (Kelly, 2022). According to the article by SWI in 2011 and the ETH, traffic lights in Zurich have mostly been programmed to prioritize trams for the last 20-30 years and thus slowing down the traffic altogether (Kelly, 2022; swissinfo.ch, 2011). Since then, some traffic signals have become traffic-dependent and adjust their phase timings according to the traffic volume.

In Switzerland, traffic participants like cyclists must follow four traffic signal phases: green, yellow, red, and red-yellow (*Ampelphasen: Diese Ampelfarben gibt es*, 2023). The phases of the red lights must be at least 2 seconds long (Fueter, 2019). The duration of the yellow phase depends on the maximum permitted speed and is regulated in the administrative regulations for road traffic rules. This can vary from 3-5 seconds (*Ampelphasen: Diese Ampelfarben gibt es*, 2023). These delays can cost road participants up to 10 seconds per traffic light (Levinson, 2018).

This paper will in the first step give an overview of the used methodology, whereas the code of the different steps will be visible in the different chapters of the paper. The results will show where the cyclist stops and why these halts occur. As a next step, the tracked trajectories will be split into different segments, which can then be cross-checked. This way, one trajectory can be built from the different segments. This will allow us to determine the most efficient trajectory. To finalize the evaluation, the most efficient determined trajectory by the authors will be compared with the trajectory suggested by stplanr to see, whether these are identical.

The following research questions were posed in this project:

1.  How do traffic lights affect the travel efficiency of a cyclist on the route from Seefeld to the Allmend Brunau in Zurich Switzerland?

2.  Is there a combination of sub-trajectories which would have fewer stops and is ultimately the most efficient route?

And the according hypotheses are the following:

-   Traffic lights decrease the travel efficiency of a cyclist, even if it is the most direct path. ​

-   The shortest path in the analysis is similar to the calculated shortest path using stplanr

# 3 Material and Methods

This paper analyzes primary data collected by Jan Burri in the time period from 01.04.2023 to 31.05.2023 by using the application POSMO project (app version 22.01.16). Only data was considered from the paths between the Allmend Brunau, Zürich, Switzerland (rugby field) and the author's home (Seefeldstrasse, Zürich Switzerland).

The following libraries were used: igraph, tidyverse, mapview, sf, tmap, raster, terra, leaflet, leaflet.extras, osrm, captioner and stplanr

In instances where the authors were stuck with coding, professors and or ChatGPT were consulted for aid. The code was, however, only interpreted and not copied, and is hence still considered our own work.

## 3.1 Pre-Processing

Datapoints which were not of the category bike were eliminated. Given there are numerous fields on the Allmend Brunau, a point (LV 95: 2681900, 1245462) which all trajectories have in common was set as an end point. Also, an identical starting point was set for all trajectories (LV 95: 2684685, 1245190).

The allocation of trajectory IDs was conducted by inserting empty rows between trajectories (identified by date and time) if not already done so by Posmo. This was necessary in one instance (2023-04-27 20:42:23).

```{r}
posmo<-read_csv("posmo.csv") |> 
 st_as_sf(coords=c("lon_x", "lat_y"), crs=4326, remove=T) |> 
  st_transform(2056)

posmo$datetime <- as.POSIXct(posmo$datetime,  tz= "UTC")

posmo_coordinates <- st_coordinates(posmo)

posmo <- cbind(posmo, posmo_coordinates)

#cleaning the data
posmo <- posmo[posmo$transport_mode=="Bike",]

#Adding new convenience variables to identify trajectories
posmo <- posmo |> 
  mutate( traj = ((ifelse(is.na(user_id)== T, "BREAK", "COMBINE")))
          )
#currently twice in file, needed to index trajectories
rle_id <- function(vec) {
    x <- rle(vec)$lengths
    as.factor(rep(seq_along(x), times = x))
}

posmo <- posmo |>
    mutate(traj_id = rle_id(traj))
```

```{r, eval=FALSE}
#visualizing it
posmo |> 
  ggplot(aes(X,Y))+
  geom_point(aes(color=traj_id))+ 
  facet_wrap(~traj_id)
```

The allocation of trajectory IDs was conducted by inserting empty rows between trajectories (identified by date and time) if not already done so by Posmo. This was necessary in one instance (2023-04-27 20:42:23).Two times two trajectories had to be pasted together which were split up due to a prolonged stop at Coop.

```{r}
#trajectory 19 seems to have combined two trajectries into one. An NA row is added between the two trajecotries that the rle_id can seperate them. 

row_index <- which(posmo$datetime == as.POSIXct("2023-04-27 20:42:23", tz="UTC"))
posmo <- posmo |> 
  add_row(.after= row_index)

posmo[row_index+1, "traj"] <- "BREAK"

posmo <- posmo |>
    mutate(traj_id = rle_id(traj))


#because of a stop at coop, trajectories 13 and 15 were split up. These will be recombined in the trajectory 15

posmo$traj_id <- ifelse(posmo$traj_id == 13, 15,posmo$traj_id)

# the same happend for traj_id 33 and 31. Will be comined in traj_id 31

posmo$traj_id <- ifelse(posmo$traj_id == 33, 31,posmo$traj_id)

#The break "trajectories" are not of interest and will be deleted and the real trajectories renumbered 
posmo <- subset(posmo, !grepl("BREAK",traj,ignore.case = T))

posmo <- posmo |>
    mutate(traj_id2 = rle_id(traj_id))
```

The different parts of the trajectories were split up by visual analysis of the plot, determining bottlenecks and setting a beginning and end point. In total, there are three sub-trajectories per trajectory.

```{r, eval=FALSE}
posmo |> 
  ggplot(aes(X,Y))+
  geom_point(aes(color=traj_id2))+
  facet_wrap(~traj_id2)

```

The traffic lights data was provided to us by the ZHAW containing 734 osm ID's and coordinates and 18 other attributes of traffic lights in Zurich. Only the attributes osm_id and geometry were kept for this analysis. Additionally, the gpkg object of the traffic lights has a CRS of WGS 84 (EPSG:4326), which is a geographic coordinate system using latitude and longitude. The posmo object has a CRS of CH1903+ / LV95 (EPSG:2056), which is a projected coordinate system specific to Switzerland.

To perform spatial operations between these two objects, they need to be in the same CRS. In this case, we can transform the lights object to CH1903+ / LV95 (EPSG:2056) using the st_transform function before using st_within.

```{r}
#traffic lights sf object
lights <- read_sf("osm_traffic_lights.gpkg")

# traffic lights and the posmo data have to have the same crs
lights <- st_transform(lights, "+proj=longlat +datum=WGS84")

#checking if the CRS has changed
str(lights)

#then keep only the columns of osm_id and geom, to facilitate the analysis
lights_clean <- lights[c("osm_id", "geom")]
```

## 3.2 Definition efficiency and segmentation

The definition of efficiency for this paper is defined by two components:

1.  Least amount of stops

2.  Shortest distance travelled

The segmentation between static and non-static was done by calculating the step length using the methods of Laube & Purves (2011). The segmentation between static and non-static was done by calculating the step length using the methods of Laube & Purves (2011).

The splitting up of groups was conducted by conducting a visual analysis of the trajectories and knowledge of the route. The trajectories were split up according to the following coordinates (Swiss CH1903+ / LV95):

-   Part A: X \<= 2682400; Y \> 1245454.8177882368

-   Part B: X \> 2682400); X \<= 2683450

-   Part C: X \> 2683450

# 4 Results

## 4.1 Segmentation of trajectories and static point analysis

Using the segmentation method, we find that there are 1168 moving points, 937 static points and 68 unclassifiable ones. Resulting in a total of 152 moving segments, 161 static segments, and 68 unclassifiable ones.

```{r}
posmo_filter <- dplyr::select(posmo,datetime, X, Y, traj_id2)

posmo_filter <- posmo_filter |> 
  rename(traj_id = traj_id2 )

#ggplot(posmo_filter, aes(X,Y, color=datetime))+
 # geom_point()

#segmentation
posmo_filter <- posmo_filter |> 
  mutate(steplength = sqrt((lead(X)-X)^2 +(lead(Y)-Y)^2))

posmo_filter <-posmo_filter |>
  group_by(traj_id) |> 
  mutate(
    n_plus1 = sqrt((lead(X,1)-X)^2 +(lead(Y,1)-Y)^2),
    n_plus2 = sqrt((lead(X,2)-X)^2 +(lead(Y,2)-Y)^2),
    n_minus1 = sqrt((lag(X,1)-X)^2 +(lag(Y,1)-Y)^2),
    n_minus2 = sqrt((lag(X,2)-X)^2 +(lag(Y,2)-Y)^2)
    )

#Static and moving
posmo_filter <- posmo_filter |> 
  rowwise() |> 
  mutate(
    stepMean =mean(c(n_minus1, n_minus2, n_plus1, n_plus2))
  ) |> 
      ungroup()

posmo_filter <- posmo_filter |> 
  group_by(traj_id) |> 
  mutate(
    traj_mean = mean(stepMean, na.rm = TRUE),
    static = stepMean < traj_mean
    ) 

#posmo_static <- posmo_filter |>
    #ungroup() |>
    #mutate(static = stepMean < mean(stepMean, na.rm = TRUE))

posmo_static <- posmo_filter |>    
    filter(static)

#indexing the trajectories
posmo_filter <- posmo_filter |>
    mutate(segment_id = rle_id(static))

posmo_filter |> 
  group_by(static, traj_id) |> 
  summarize(count = length(unique(segment_id))) |> 
  group_by(static) |> 
  summarize(total = sum(count))

```

The resulting static and moving points were visualized in the plot below.

```{r}
#visualizing segment trajectories
posmo_filter |> 
  mutate(static =stepMean < mean(stepMean, na.rm =TRUE)) |> 
  ggplot(aes(X,Y))+
  geom_path()+
  geom_point(aes(color=static))+
  coord_fixed()
```

*Figure 0: Visualization of the static and moving points using the segmentation method by Laube & Purves 2011*

## 4.2 Differentiation into sub-trajectories

Looking at the plot below, we can see two obvious bottlenecks. These were used as a segmentation to determine the most efficient sub trajectories. All three Parts (A, B, and C) consist of 17 trajectories. Many of these trajectories are, however, similar to one another. Grouping the trajectories with overlays of over 85%, resulted in 3, 6, and 4 groups for Parts A, B, and C respectively. Looking at the Table below, we can see the number of trajectories per group. The most commonly used path is the group 2 in Part A, group 3 in Part B, and group 1 in group C. Out of the three groups, B is the most evenly distributed.

| Group_ID | Part A | Part B | Part C |
|:--------:|:------:|:------:|:------:|
|    1     |   1    |   4    |   12   |
|    2     |   13   |   1    |   1    |
|    3     |   3    |   5    |   3    |
|    4     |   NA   |   4    |   1    |
|    5     |   NA   |   2    |   NA   |
|    6     |   NA   |   1    |   NA   |

*Table 1: Number of similar sub-trajectories per group ID*

```{r, include=TRUE, fig.cap="Figure: All data points of the trajectories recorded"}
mapview(posmo_filter, zcol = "traj_id", col.regions = rainbow(length(unique(posmo_filter$traj_id))))

```

*Figure 1: All data points of the trajectories recorded*

```{r}
#Adding a starting and finish point to each Traj Id
posmo_filter <- posmo_filter |> 
  dplyr::select(datetime,X,Y,traj_id,geometry,segment_id,static)


n_traj <- length(unique(posmo_filter$traj_id))

start_end <- data.frame(traj_id = 1:n_traj,
                   X = rep(2681900, n_traj),
                   Y = rep(1245462, n_traj), 
                   static = F,
                   datetime = NA, 
                   segment_id= NA)

start_end <-bind_rows(start_end, data.frame(traj_id = 1:n_traj,
                   X = rep(2684685, n_traj),
                   Y = rep(1245190, n_traj), 
                   static = F,
                  datetime = NA, 
                   segment_id= NA))

start_end$traj_id <- as.factor(start_end$traj_id)

start_end <- st_as_sf(start_end, coords = c("X", "Y"), crs = 2056, remove = F)

head(posmo_filter)
head(start_end)

posmo_filter <-rbind(posmo_filter, start_end)


#Splitting the trajectory into different parts according to bottlenecks
A_part <- posmo_filter |> 
  filter(X <= 2682400) |> 
  filter(Y > 1245454.8177882368) 

B_part <- posmo_filter |> 
  filter(X > 2682400) |> 
  filter(X <= 2683450)

C_part <- posmo_filter |> 
  filter(X > 2683450)

```

```{r, eval=FALSE}
#Visualizing the different sub-trajectories and checking individual trajectories for anomalies
A_part |> 
  filter(static ==F) |>
  ggplot(aes(X,Y))+
  geom_point(aes(color=traj_id))+ 
  facet_wrap(~traj_id)

A_part |> 
  filter(traj_id==1) |> 
  mapview()
```

### 4.2.1 Similarity and grouping of trajectories

We checked for overlaps between the trajectories of part A, part B, and part C. For part A, we grouped the trajectories by traj_id and created a new column do_union with the value FALSE. We then cast the data to LINESTRING geometry. Then, we created a buffer around the part A trajectories using a distance of 50 meters.

We calculated the number of rows in the part A buffer and created an empty matrix A_mymat with the same number of rows and columns. THrough each pair of trajectories in part A, we checked for self-intersection and calculating the intersection area ratio. If the trajectories were the same, we assigned NA to the matrix; otherwise, we calculated the intersection area ratio using the **`st_area()`** and **`st_intersection()`** functions.

Using the intersection area ratio matrix, we constructed a graph object traj_group representing the connections between trajectories. We set a threshold of 0.85 for the adjacency matrix to define connections.

We repeated the same steps for part B and part C, calculating overlaps, creating buffers, calculating intersection area ratios, and assigning group IDs..

Finally, we visualized the trajectories of part C by grouping them by group_id, casting to LINESTRING, and plotting them using the **`plot()`** function.

```{r}
#Checking for overlaps between the trajectories

A_part_lines <- A_part |> 
  group_by(traj_id) |> 
  summarise(do_union = FALSE) |> 
  st_cast("LINESTRING") 

A_part_lines_buff <- A_part_lines |> 
  st_buffer(50)

A_n_traj <- nrow(A_part_lines_buff)
A_mymat <- matrix(nrow = A_n_traj, ncol = A_n_traj)

for (i in 1:A_n_traj) {
  for (j in 1:A_n_traj) {
    if (i == j) {
      A_mymat[i, j] <- NA
    } else {
      inter <- st_intersection(A_part_lines_buff[i, ], A_part_lines_buff[j, ])
      A_mymat[i, j] <- as.numeric(st_area(inter)) / as.numeric(st_area(A_part_lines_buff[i, ]))
    }
  }
}

traj_group <- graph_from_adjacency_matrix(A_mymat> 0.85, mode = "undirected", weighted = TRUE, diag = FALSE)
#plot(traj_group)

group_ids <- clusters(traj_group)$membership

A_part_lines$group_id<-group_ids

A_part <- left_join(A_part,st_drop_geometry(A_part_lines), by="traj_id")

#B_Part

B_part_lines <- B_part |> 
  group_by(traj_id) |> 
  summarise(do_union = FALSE) |> 
  st_cast("LINESTRING") 

B_part_lines_buff <- B_part_lines |> 
  st_buffer(50)

B_n_traj <- nrow(B_part_lines_buff)
B_mymat <- matrix(nrow = B_n_traj, ncol = B_n_traj)

for (i in 1:B_n_traj) {
  for (j in 1:B_n_traj) {
    if (i == j) {
      B_mymat[i, j] <- NA
    } else {
      inter <- st_intersection(B_part_lines_buff[i, ], B_part_lines_buff[j, ])
      B_mymat[i, j] <- as.numeric(st_area(inter)) / as.numeric(st_area(B_part_lines_buff[i, ]))
    }
  }
}

traj_group <- graph_from_adjacency_matrix(B_mymat> 0.85, mode = "undirected", weighted = TRUE, diag = FALSE)
#plot(traj_group)

group_ids <- clusters(traj_group)$membership

B_part_lines$group_id<-group_ids

B_part <- left_join(B_part,st_drop_geometry(B_part_lines), by="traj_id")

#C_Part

C_part_lines <- C_part |> 
  group_by(traj_id) |> 
  summarise(do_union = FALSE) |> 
  st_cast("LINESTRING") 

C_part_lines_buff <- C_part_lines |> 
  st_buffer(50)

C_n_traj <- nrow(C_part_lines_buff)
C_mymat <- matrix(nrow = C_n_traj, ncol = C_n_traj)

for (i in 1:C_n_traj) {
  for (j in 1:C_n_traj) {
    if (i == j) {
      C_mymat[i, j] <- NA
    } else {
      inter <- st_intersection(C_part_lines_buff[i, ], C_part_lines_buff[j, ])
      C_mymat[i, j] <- as.numeric(st_area(inter)) / as.numeric(st_area(C_part_lines_buff[i, ]))
    }
  }
}

traj_group <- graph_from_adjacency_matrix(C_mymat> 0.85, mode = "undirected", weighted = TRUE, diag = FALSE)
#plot(traj_group)

group_ids <- clusters(traj_group)$membership

C_part_lines$group_id<-group_ids

C_part <- left_join(C_part,st_drop_geometry(C_part_lines), by="traj_id")

#counting the number of trajectories per group_id

A_part |> 
  group_by(group_id) |> 
  summarize(n = n_distinct(traj_id))

B_part |> 
  group_by(group_id) |> 
  summarize(n = n_distinct(traj_id))

C_part |> 
  group_by(group_id) |> 
  summarize(n = n_distinct(traj_id))

B_part |> 
  filter(traj_id==1) 


```

```{r, eval=FALSE}
#Visualizing it
C_part |> 
  group_by(group_id) |> 
  summarise(do_union = FALSE) |> 
  st_cast("LINESTRING") |> 
  plot()

C_part |> 
  group_by(group_id) |> 
  ggplot(aes(X,Y, color=group_id))+
  geom_path()
```

### 4.2.2 Number of stops per sub-trajectory

In the analysis of sub-trajectories and stops, we started by examining the number of stops per sub-trajectory. We focused on three different parts: A, B, and C. For part A, we filtered the data to include only the rows where the static variable was set to TRUE. Then, we identified the unique combinations of traj_id and segment_id"and grouped the data by traj_id. By calculating the count of stops using the **`n()`** function, we obtained the number of stops per sub-trajectory for part A.

Similarly, we followed the same approach for parts B and C, filtering the data and computing the count of stops for each part. Afterward, we moved on to examining the number of stops per group.

To calculate the mean number of stops per group for part A, we introduced the "group_id" column to the "A_stop" data frame. Using the **`mutate()`** function and matching the traj_id values, we assigned the corresponding group ID to each sub-trajectory. Next, we grouped the data by "group_id" and computed the mean number of stops per group using the **`mean()`** function. We repeated this process for parts B and C, obtaining the mean number of stops per group for each part.

To consolidate the information, we created new columns labeled "Part" in each of the mean stop data frames: "A_stop_mean," "B_stop_mean," and "C_stop_mean." These columns indicated the respective parts A, B, or C. Finally, we merged the three mean stop data frames using the **`bind_rows()`** function, resulting in the stop_mean data frame. The geometry column was dropped using the **`st_drop_geometry()`** function, leaving us with a comprehensive dataset that captured the mean number of stops per group across all three parts.

```{r}
# Want to count the number of stops per part per trajectory
A_stop <- A_part |>
  filter(static == T) |> 
  distinct(traj_id, segment_id) |> 
  group_by(traj_id) |> 
  summarize(Stops = n())

B_stop <- B_part |>
  filter(static == T) |> 
  distinct(traj_id, segment_id) |> 
  group_by(traj_id) |> 
  summarize(Stops = n())

C_stop <- C_part |>
  filter(static == T) |> 
  distinct(traj_id, segment_id) |> 
  group_by(traj_id) |> 
  summarize(Stops = n())



#Now per group
A_stop_mean <- A_stop |> 
  mutate(group_id = A_part$group_id[match(traj_id, A_part$traj_id)]) |> 
  group_by(group_id) |> 
  summarize(mean_stops = mean(Stops))

B_stop_mean <- B_stop |> 
  mutate(group_id = B_part$group_id[match(traj_id, B_part$traj_id)]) |> 
  group_by(group_id) |> 
  summarize(mean_stops = mean(Stops))

C_stop_mean <- C_stop |> 
  mutate(group_id = C_part$group_id[match(traj_id, C_part$traj_id)]) |> 
  group_by(group_id) |> 
  summarize(mean_stops = mean(Stops))



#combination of the three
A_stop_mean<- A_stop_mean |> 
  mutate(Part= "A")

B_stop_mean<- B_stop_mean |> 
  mutate(Part= "B")

C_stop_mean<- C_stop_mean |> 
  mutate(Part= "C")

stop_mean <- bind_rows(A_stop_mean, B_stop_mean, C_stop_mean) |> 
  st_drop_geometry()


```

### 4.2.3 Length of the sub-trajectories

In this analysis, our goal was to determine the length of each sub-trajectory, specifically focusing on the moving segments. We followed a series of steps for each part (A, B, and C) to compute the lengths accurately.

First, we filtered the data to include only the rows where the "static" variable was set to "FALSE," indicating the moving segments. Then, we grouped the data by "traj_id" and calculated the Euclidean distance between consecutive points using their X and Y coordinates. This was done by applying the formula sqrt((lead(X,1)-X)\^2 +(lead(Y,1)-Y)\^2). By grouping the data again by "traj_id" and summarizing the distances, we obtained the lengths of the sub-trajectories.

Moving on to the mean length calculations per group, we added a "group_id" column to each length data frame. To do this, we matched the "traj_id" values with the corresponding group ID from the respective part (A_part, B_part, or C_part). We then grouped the data by "group_id" and computed the mean length of the sub-trajectories within each group using the **`mean()`** function.

To combine the results from all three parts, we included a "Part" column in each mean length data frame: "A_length_mean," "B_length_mean," and "C_length_mean." This column indicated the respective part (A, B, or C) for each row. Finally, we merged the three mean length data frames using the **`bind_rows()`** function and removed the geometry column using the **`st_drop_geometry()`** function. The resulting data frame, named "Length_mean," provided the mean length of sub-trajectories per group across all three parts.

```{r}
#Want to know the length of each trajectory, we have to recompute this to know only the length of the moving segments
A_length<- A_part |> 
  filter(static==F) |> 
  group_by(traj_id) |> 
  mutate(distance = sqrt((lead(X,1)-X)^2 +(lead(Y,1)-Y)^2))|> 
  group_by(traj_id) |> 
  summarize(length = sum(distance, na.rm=T))

B_length<- B_part |> 
  filter(static==F) |> 
  group_by(traj_id) |> 
  mutate(distance = sqrt((lead(X,1)-X)^2 +(lead(Y,1)-Y)^2))|> 
  group_by(traj_id) |> 
  summarize(length = sum(distance, na.rm=T))

C_length<- C_part |> 
  filter(static==F) |> 
  group_by(traj_id) |> 
  mutate(distance = sqrt((lead(X,1)-X)^2 +(lead(Y,1)-Y)^2))|> 
  group_by(traj_id) |> 
  summarize(length = sum(distance, na.rm=T))



#Now per group
A_length_mean <- A_length |> 
  mutate(group_id = A_part$group_id[match(traj_id, A_part$traj_id)]) |> 
  group_by(group_id) |> 
  summarize(mean_length = mean(length))

B_length_mean <- B_length |> 
  mutate(group_id = B_part$group_id[match(traj_id, B_part$traj_id)]) |> 
  group_by(group_id) |> 
  summarize(mean_length = mean(length))

C_length_mean <- C_length |> 
  mutate(group_id = C_part$group_id[match(traj_id, C_part$traj_id)]) |> 
  group_by(group_id) |> 
  summarize(mean_length = mean(length))


#combination of the three
A_length_mean<- A_length_mean |> 
  mutate(Part= "A")

B_length_mean<- B_length_mean |> 
  mutate(Part= "B")

C_length_mean<- C_length_mean |> 
  mutate(Part= "C")

Length_mean <- bind_rows(A_length_mean, B_length_mean, C_length_mean) |> 
  st_drop_geometry()
```

## 4.3 Assessment of the most efficient route

Looking at the different groups which have been created, we wanted to determine what the average number of stops per group_id is. The segmentation of movement allowed us to compute the length of moving segments and with it the number of stops per sub-trajectory. The analysis resulted in the following different average numbers of stops per group (visualization). One can see, that group C shows the largest variation in the number of stops per group, ranging from three to six stops. Group B shows less of a deviation, however, does have one outlier with only two stops. Group A shows the smallest number of stops, also being the most constant.

```{r}
stop_mean |> 
    ggplot(aes(Part,mean_stops))+
  geom_boxplot(color = "steelblue", fill = "lightblue", width = 0.5) +
  labs( x = "Group", y = "Number of Stops") +
  theme_minimal()
  
```

*Figure 2: Boxplot of number of stops per Part*

The mean length per group_id was computed in a similar manner. In the first step, the distances between moving points on a trajectory level were computed and summed. These were afterwards averaged per group. The following graph shows the variation of lengths per the three parts of travel. One can see that Group C is the longest part of the trip averaging 2200 m, having however an outlier at over 3250 m. Part B is the shortest group with an average of 1250 m. Its outlier of 1500 m is shorter than the mean of Part A at 1700 m. Part A does however have a trajectory that is comparably long to the mean of Part B.

```{r}
Length_mean |> 
  ggplot(aes(Part,mean_length))+
  geom_boxplot(color = "steelblue", fill = "lightblue", width = 0.5) +
  labs( x = "Group", y = "Mean Length per Group (in meters)") +
  theme_minimal()
```

*Figure 3: Boxplot of length of different trajectories*

### 4.3.1 Linear Normalization and Scoring

Knowing the average length and number of stops per group, a linear normalization was applied to make the figures compatible with one another. Stops being perceived as more tedious by the cyclist, these were multiplied by a factor of 0.6, whereas the length with a factor of 0.4.

```{r}
A <- left_join(A_length_mean, A_stop_mean, by= "group_id") |> 
  st_drop_geometry() 

B <- left_join(B_length_mean, B_stop_mean, by= "group_id")|> 
  st_drop_geometry() 

C <- left_join(C_length_mean, C_stop_mean, by= "group_id")|> 
  st_drop_geometry() 

#Normalizing (linear) the stops and distances and valuing stops over distance

A <- A |> 
  mutate(
    normalized_stops = (mean_stops - min(mean_stops)) / (max(mean_stops) - min(mean_stops)),
    normalized_distance = ((mean_length - min(mean_length)) / (max(mean_length) - min(mean_length))),
    score = 0.6 * normalized_stops + 0.4 * normalized_distance
  )

B <- B |> 
  mutate(
    normalized_stops = (mean_stops - min(mean_stops)) / (max(mean_stops) - min(mean_stops)),
    normalized_distance =((mean_length - min(mean_length)) / (max(mean_length) - min(mean_length))),
    score = 0.6 * normalized_stops + 0.4 * normalized_distance
  )

C <- C |> 
  mutate(
    normalized_stops = (mean_stops - min(mean_stops)) / (max(mean_stops) - min(mean_stops)),
    normalized_distance = ((mean_length - min(mean_length)) / (max(mean_length) - min(mean_length))),
    score = 0.6 * normalized_stops + 0.4 * normalized_distance
  )
    
  
# Assigning the score to the sub-trajectories

A_part <- A |> 
  dplyr::select(group_id, score) |> 
  left_join(A_part, A, by= "group_id")

B_part <- B |> 
  dplyr::select(group_id, score) |> 
  left_join(B_part, B, by= "group_id")

C_part <- C |> 
  dplyr::select(group_id, score) |> 
  left_join(C_part, C, by= "group_id")

# the most efficient trajectory
best_path <- A_part |> 
  filter(score == min(score))

best_path <- bind_rows(best_path, B_part |> 
  filter(score == min(score)))

best_path <- bind_rows(best_path, C_part |> 
  filter(score == min(score))) 

best_path <-  st_as_sf(best_path, sf_column_name= "geometry")


best_path_trajectory <- best_path |> 
  group_by(group_id) |> 
  summarize(geometry = st_combine(geometry)) |> 
  st_cast("MULTILINESTRING")
```

```{r}
mapview(best_path_trajectory)
```

*Figure 4: The most efficient trajectory according to the weighted normalization.*

The results show, that in Part A group 3 showed the most efficient score according to our definition. An average of 2.3 stops proved to be the least amount of stops for this Part of the trip. The trajectory is however 1636m the second longest.Part B proves that group 1 is the obvious choice out of the six groups, containing the smallest number of stops (2) and the shortest distance (1107m).Part C too shows to have a group trajectory in which both have the smallest number of stops (3) and is the shortest in distance (2032m), group_id 2.

The combined trajectory is 4775m long and contains 7.3 stops.

## 4.4 Intersection of traffic lights during the trip

### 4.4.1 Buffering and Spatial Join

A buffer was created around the lights_clean object using the **`st_buffer`** function. The buffer distance was set to 5 meters. The result of the operation was assigned to the variable lights_buffer. A spatial join was conducted using the **`st_join`** function with the posmo_map and lights_buffer objects. The join operation was specified as st_intersects, which returns the intersecting geometries between the two objects. The result of the join was assigned to the joined_data object. Next, any NA values in the joined_data object were removed using the `na.omit` function. This step eliminated data points that were not within the buffer. With this step we could see that in total 57 traffic lights intersected 12 trajectories including also non-static points.

```{r}
# Creating a buffer around the lights_clean object
lights_buffer <- st_buffer(lights_clean, dist = 5)
#spatial join using st_intersects
posmo_map  <- st_transform(posmo_filter, "+proj=longlat +datum=WGS84")
joined_data <- st_join(posmo_map, lights_buffer,  join = st_intersects)

#NA values removal of the data points that were not in the buffer
joined_data<- na.omit(joined_data)

```

Because we already established which points are static, the joined dataset was filtered to retain static points. The dataset (See Table 2 below), presented a total of 34 static points in 12 trajectories, which were at a buffered traffic light.

```{r}
# Filtering the joined data for points with static = TRUE
joined_data <- filter(joined_data, joined_data$static==T)

#keeps only the first (earliest) record within each group
joined_data <- joined_data |> 
  group_by(traj_id, osm_id) |> 
  slice_min(datetime, n = 1) |> 
  ungroup()
```

```{r}
knitr::kable(joined_data)
```

*Table 2: Output of the traffic lights that affected the travel efficiency on different trajectories*

To visualize the affected trajectories, and the points belonging to the selected trajectories we grouped them by trajectory ID. These points were then combined into a single LineString representation for each trajectory using the summarize and **`st_combine`** functions. The dataset, Trajectories_with_stops, consisted of the combined LineString geometries representing the affected trajectories. The interactive map using **`mapview`** is shown below.

```{r}
# Group points by trajectory ID and combine them into a single LineString for each trajectory that was affected by the stop.
posmo_map <- na.omit(posmo_map)
selected_trajectories <- c(1, 2, 3, 7,8,10,12, 13,14, 15,16,17)

Trajectories_with_stops <- posmo_map |>
  filter(traj_id %in% selected_trajectories) |> 
  group_by(traj_id)  |> 
  summarize(geometry = st_combine(geometry)) |> 
  st_cast("MULTILINESTRING")

#plot the interactive map with mapview
Traffic_Lights <- joined_data

lights_map <- mapview(Traffic_Lights)

# Create a mapview object for the GPS points
lines_map <- mapview(Trajectories_with_stops)

# Combine the two mapview objects into a single map
combined_map <- lights_map + lines_map

```

```{r, fig.cap="Figure: Mapview of the trajectories that were affected by traffic lights"}
# Viewing the combined map
combined_map
```

*Figure 6: Mapview of the trajectories that were affected by traffic lights*

### 4.4.1 Possible traffic lights on the most efficient route

For the three sub-trajectories we performed a spatial join using the **`st_intersects`** function to join the best_path and lights_buffer datasets. The best_path was transformed to the WGS84 coordinate system. The resulting dataset, best_path_lights, was obtained by joining the two datasets based on their spatial intersection.

To ensure data consistency, we removed any NA values from the best_path_lights dataset and selected only the osm_id and geom columns for further analysis.To convert the polygons in the best_path_lights dataset into points, we used the **`st_centroid`** function. For the visualization, we utilized the **`mapview`** package to create interactive maps.

```{r}

#spatial join using st_intersects
best_path<- st_transform(best_path, "+proj=longlat +datum=WGS84")
best_path_lights <- st_join(lights_buffer, best_path,  join = st_intersects)

#NA values removal of the data points that were not in the buffer
best_path_lights<- na.omit(best_path_lights)
best_path_lights<- dplyr::select(best_path_lights, osm_id, geom)

#Converting polygons into points
best_path_lights <- st_centroid(best_path_lights)

#plotting the interactive map with mapview
Traffic_Lights <- mapview(best_path_lights)

Best_path_map <- mapview(best_path_trajectory)

# Combining the two mapview objects into a single map
combined_map_3 <- Traffic_Lights + Best_path_map
```

```{r}
# Viewing the combined map
combined_map_3
```

*Figure 7: Interactive map of the trajectory of the most efficient path and the traffic lights, which could possibly delay the travelling time*

The most efficient path of three sub-trajectories intersects 8 traffic lights in total.

## 4.5 Computation of the shortest path with stplanr

The **`route()`** function of the stplanr package was used to compute the route between paths between the Allmend Brunau, Zürich, Switzerland (8.5230702, 47.3550564) and Seefeldstrasse( 8.5593665, 47.3526167) using the OSRM back-end as the route calculation method and setting returnclass to "sf". The computed route was stored in the computed_route object. By performing a spatial join between the lights_buffer and computed_route objects, we identified the traffic lights along the computed route. We used the **`mapview`** function to create an interactive map of both objects, resulting in the interactive map below.

```{r}
# The start and endpoint coordinates
start <- c(8.5593665, 47.3526167)
end <- c(8.5230702, 47.3550564)

#Computing the shortest path
computed_route <- route(from = start, to = end, route_fun = osrmRoute, returnclass = "sf")
# Including the traffic lights
computed_route<- st_transform(computed_route, "+proj=longlat +datum=WGS84")

computed_route_stops <- st_join( lights_buffer,computed_route,join = st_intersects)
computed_route_stops <- na.omit(computed_route_stops)

computed_route_lights <- dplyr::select(computed_route_stops, osm_id, geom)
#Converting polygons into points
computed_route_lights <- st_centroid(computed_route_lights)

#plotting the interactive map with mapview
computed_lights_map <- mapview(computed_route_lights)
computed_map<- mapview(computed_route)

# Combining the two mapview objects into a single map
combined_map_2 <- computed_map + computed_lights_map
```

```{r}
combined_map_2
```

*Figure 8: Interactive map of the computed shortest path and possible traffic lights along the path from the set start and end points*

The computed shortest path has a length of 5052 meters and crosses 31 traffic lights.

# 5 Discussion

### 5.1 Problems with Map matching

Map matching is not only difficult to conduct, but it can also cause more harm than benefits by positioning points on false roads or other items. Due to this, we refrained from conducting this and kept the points at their position placed by Posmo. The not-classifiable segments can be routed back to the splitting of trajectories of Posmo, which leads to a row containing NAs.

### 5.2 Missing temporal analysis

In our pre-processing, we decided not to determine the duration of the trajectories as the most efficient path, because they were influenced by the cyclists changing cycling behaviour from going to the training and back. We, therefore, chose not to use this biased data and rather focused on the shortest route and the least amount of stops. In the future, we would consider collecting data, that involves the time duration without these circumstances.

### 5.3 Assessment of traffic lights

The number of stops (static segments) can partially be accounted for by the traffic lights, although out of 937 static points, only 34 could be determined as stops at traffic lights. As metioned before, the unprecise data points could have influenced the intersection analysis with the traffic lights. In addition, it could also be due to other factors influencing the cyclist like f.e. right-of-way markings. Another factor is that at most junctions' traffic lights occur as tight clusters and are computed in the buffer. This phenomenon can be  observed in trajectory 16 (2023-05-25T17:26) where during this one minute the traffic lights with the osm_id 2114258, 300390846 were considered as the cause of the stop. If we had more precise data, we would consider reducing the buffer size or applying a clustering algorithm to the traffic lights.

In the joined_data table, we can observe, that the trajectory with the most stops is trajectory 3. There were in total 5 stops at a traffic light at different times and coordinates. Unfortunately, trajectory 3 does present a lot of problems with the incorrect GPS coordinates and so the stops should be interpreted with care. In addition, the traffic lights data does contain all the traffic lights within a junction, so some traffic lights could be buffered within the trajectory, even though it was not causing a stop.

In general, we can say, that there were not many static hotspots, where the cyclists stopped the most at traffic lights throughout all trajectories. One of the most stops was at Utoquai, which contains a complex junction. Trajectories 14, 15, 16, and 8 all had a static point at one traffic light (osm_id: 2114258). We can therefore say, that this stop was most likely due to a traffic light.

Altogether we can only guess, that taking the side roads, would lead to fewer stops for the cyclist. For a more precise interpretation, we would have to map and match the trajectories exactly to the streets and then repeat our analysis.

### 5.4 Comparison with computed path

```{r}
combined_map_2
```

*Figure 9: Interactive map of the computed trajectory of the most efficient path and the traffic lights, which could possibly delay the travelling time*

```{r}
combined_map_3
```

*Figure 10: Interactive map of the calculated trajectory of the most efficient path from our data sets and the traffic lights, which could possibly delay the travelling time*

In the comparison of the computed shortest path and the three sub-trajectories we determined as the shortest path, the sub-trajectories groups 1 and 3 align almost with the computed path. The sub-trajectory 1 contains many jitters in one part, but as we can make out, the route that the program chose is better through the Alfred-Escher Strasse. The sub-trajectory group 2 aligns in the first part with the computed trajectory and then diverges at the Höschgasse. Although this route presumably doesn't contain any traffic lights like in the computed route, we can also observe, that they do not match perfectly to the road network. So in this case, the cyclist could still be delayed by traffic lights. By looking at the distance our calculated path is shorter than the computed path. In this case, we would recommend using our calculated route.

### 5.5 Perception of the cyclist

The computed most efficient trajectory is also perceived as the most efficient one in real life. This is shown by the number of times the trajectory was taken by the cyclist in Part A and Part B. The trajectory in Part A goes along the main road (as all trajectories), followed by a parallel stream where only pedestrians and cyclists are permitted. Hence, no traffic lights are present. Part B shows a lot of movement, especially around the train station Enge. This is due to the many possible and taken trajectories. The data collection interval, however, was not fast enough in locating the cyclist and hence has led to confusions. It was considered by correcting this by using map matching, was however not conducted due to likelihood of the quality of data deteriorating further. Part C is however slightly astonishing, given this route was only taken once. It leads along the main road and does cross several intersections, some of them which also contain traffic lights. Due to the buffer issue with the traffic lights however, these were not caught by the code. The cyclist deems the trajectory along Dufourstrasse more efficient, given it is the same length, however with less lights given the trams and main traffic runs along the Seefeldstrasse.

# 6 Conclusion

Altogether opting to avoid main roads and choosing alternative routes depending on the daytime, amounts of traffic lights and traffic conditions can potentially turn out to be the most efficient and shortest path. Additionally, using navigation apps or computing systems can provide real-time information on the current traffic conditions, helping to make informed decisions about the most efficient route to take.

# References

*Ampelphasen: Diese Ampelfarben gibt es*. (2023, June 6). ADAC. <https://www.adac.de/verkehr/recht/verkehrsvorschriften-deutschland/ampel/>

Fueter, O. (2019, January 19). «Espresso Aha!»---Eine Norm bestimmt, wie lange es Orange bleibt. *Schweizer Radio und Fernsehen (SRF)*. <https://www.srf.ch/sendungen/kassensturz-espresso/eine-norm-bestimmt-wie-lange-es-orange-bleibt>

Kelly, K. (2022, April 14). Intelligent traffic lights for optimal traffic flow. *ETH Zürich*. <https://ethz.ch/en/industry/industry/news/data/2022/04/intelligent-traffic-lights-for-optimal-traffic-flow.html>

Laube, P., & Purves, R. S. (2011). How fast is a cow? Cross-Scale Analysis of Movement Data: Cross-Scale Trajectory Analysis. *Transactions in GIS*, *15*(3), 401--418. <https://doi.org/10.1111/j.1467-9671.2011.01256.x>

Levinson, D. (2018, March 5). How much time is spent at traffic signals? *David Levinson, Transportist*. <https://transportist.org/2018/03/06/how-much-time-is-spent-at-traffic-signals/>

swissinfo.ch, \<Matthew Allen\> in Zurich. (2011, July 7). *Zurich streets among Europe's most congested*. SWI Swissinfo.Ch. <https://www.swissinfo.ch/eng/zurich-streets-among-europe-s-most-congested/30634398>

TomTom Traffic Index. (2022). *Switzerland traffic report*. Switzerland Traffic Report \| TomTom Traffic Index. <https://www.tomtom.com/traffic-index/switzerland-country-traffic/>

TomTom Traffic Index. (2023, June 28). *Zurich traffic report*. <https://www.tomtom.com/traffic-index/zurich-traffic/>
